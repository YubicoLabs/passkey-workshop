"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[240],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(n),h=i,m=c["".concat(l,".").concat(h)]||c[h]||p[h]||r;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,o[1]=s;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6977:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:2},o="Relying party implementation",s={unversionedId:"advanced_use_cases/attestation/relying-party-implementation",id:"advanced_use_cases/attestation/relying-party-implementation",title:"Relying party implementation",description:"This section will cover how to add attestation support to your relying party. Because the java-webauthn-server library supports attestation and the FIDO MDS out of the box, the changes are minimal. The changes should also be non-disruptive to the users who opt not to use attestation.",source:"@site/docs/advanced_use_cases/attestation/relying-party-implementation.md",sourceDirName:"advanced_use_cases/attestation",slug:"/advanced_use_cases/attestation/relying-party-implementation",permalink:"/passkey-workshop/docs/advanced_use_cases/attestation/relying-party-implementation",draft:!1,editUrl:"https://github.com/YubicoLabs/passkey-workshop/tree/main/docs/docs/advanced_use_cases/attestation/relying-party-implementation.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/passkey-workshop/docs/advanced_use_cases/attestation/overview"}},l={},d=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Configuration changes",id:"configuration-changes",level:2},{value:"Registration response method changes",id:"registration-response-method-changes",level:2},{value:"Credential repository considerations",id:"credential-repository-considerations",level:2}],u={toc:d},c="wrapper";function p(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"relying-party-implementation"},"Relying party implementation"),(0,i.kt)("p",null,"This section will cover how to add attestation support to your relying party. Because the java-webauthn-server library supports attestation and the FIDO MDS out of the box, the changes are minimal. The changes should also be non-disruptive to the users who opt not to use attestation."),(0,i.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,i.kt)("p",null,"Ensure that you have deployed the sample found in this project. The project uses the FIDO MDS by default, and can be enabled/disabled by setting the following configuration in the ",(0,i.kt)("inlineCode",{parentName:"p"},"DeployProject.conf")," file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Will denote if your application will leverage attestation\n# Through the FIDO MDS\n# Default: mds\n# Options: mds, none\nRP_ATTESTATION_TRUST_STORE=\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/deploy"},"Follow the instructions on this page to deploy the application.")),(0,i.kt)("h2",{id:"configuration-changes"},"Configuration changes"),(0,i.kt)("p",null,"First we will attempt to change the original configurations that we set for the application's ",(0,i.kt)("inlineCode",{parentName:"p"},"RelyingParty")," changes (",(0,i.kt)("a",{parentName:"p",href:"/docs/relying-party/config-and-data#rp-configurations"},"this was covered in the previous section on relying party guidance"),")."),(0,i.kt)("p",null,"Below is the original configuration that we used to initialize our application. Note the highlighted line that contains the property ",(0,i.kt)("inlineCode",{parentName:"p"},"attestationTrustSource"),". When we created this object, we initialized it as null."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"{33}","{33}":!0},'package com.yubicolabs.passkey_rp.services.passkey;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.annotation.PostConstruct;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Service;\n\nimport com.yubico.webauthn.RelyingParty;\nimport com.yubico.webauthn.data.AttestationConveyancePreference;\nimport com.yubico.webauthn.data.RelyingPartyIdentity;\nimport com.yubicolabs.passkey_rp.services.storage.StorageInstance;\n\nimport lombok.Getter;\n\npublic class RelyingPartyInstance {\n\n  @Getter\n  private RelyingParty relyingParty;\n\n  @PostConstruct\n  private void setRPInstance() {\n    this.relyingParty = RelyingParty.builder()\n        .identity(generateIdentity())\n        .credentialRepository(storageInstance.getCredentialStorage())\n        .origins(generateOrigins())\n        .attestationConveyancePreference(\n            AttestationConveyancePreference.valueOf(System.getenv("RP_ATTESTATION_PREFERENCE")))\n        .allowUntrustedAttestation(Boolean.parseBoolean(System.getenv("RP_ALLOW_UNTRUSTED_ATTESTATION")))\n        .attestationTrustSource(null) // Set this field to null, we will cover this in detail in the section on attestation\n        .validateSignatureCounter(true)\n        .build();\n  }\n}\n')),(0,i.kt)("p",null,"We will extend this example to download, initialize, and globally use the FIDO MDS. First we will define a method to initialize the MDS in our application."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'/**\n * Helps the application to determine if it will use a metadata repository to\n * determine trusted attestation\n * Currently the only data source configured is a downloadable version of the\n * FIDO MDS\n *\n * @return an optional object that is either:\n *         A downloaded version of the FIDO MDS\n *         null indicating not to use an attestation store\n */\nprivate FidoMetadataService resolveAttestationTrustSource() {\n  /**\n   * Using the env variable set by the DeployProject.conf file\n   */\n  String attestationTrustStoreType = System.getenv("RP_ATTESTATION_TRUST_STORE");\n\n  /**\n   * System is set to utilize the MDS\n   */\n  if (attestationTrustStoreType.equals("mds")) {\n    try {\n      /**\n       * Setting needed in order to download the MDS\n       * More information here:\n       * https://github.com/Yubico/java-webauthn-server/tree/main/webauthn-server-attestation#:~:text=By%20default%2C,Guide%20for%20details.\n       */\n      System.setProperty("com.sun.security.enableCRLDP", "true");\n\n      /**\n       * Initialize helper to download the MDS\n       */\n      FidoMetadataDownloader downloader = FidoMetadataDownloader.builder()\n          /**\n           * Ensure that you have read FIDO\'s legal header to understand the implications\n           * of using the FIDO MDS\n           * More information here:\n           * https://developers.yubico.com/java-webauthn-server/JavaDoc/webauthn-server-attestation/2.0.0/com/yubico/fido/metadata/FidoMetadataDownloader.FidoMetadataDownloaderBuilder.Step1.html\n           */\n          .expectLegalHeader(\n              "Retrieval and use of this BLOB indicates acceptance of the appropriate agreement located at https://fidoalliance.org/metadata/metadata-legal-terms/")\n          .useDefaultTrustRoot()\n          /**\n           * Cache the trust root cert and blob in a tmp folder for later use\n           */\n          .useTrustRootCacheFile(new File("/tmp/fido-mds-trust-root-cache.bin"))\n          .useDefaultBlob()\n          .useBlobCacheFile(new File("/tmp/fido-mds-blob.bin"))\n          .build();\n\n      FidoMetadataService mds = FidoMetadataService.builder()\n          .useBlob(downloader.loadCachedBlob())\n          .build();\n\n      return mds;\n    } catch (Exception e) {\n      /**\n       * There was an issue initializing the MDS\n       * Opting not to use the MDS\n       */\n      e.printStackTrace();\n      return null;\n    }\n  } else { // System should not utilize any MDS\n    return null;\n  }\n}\n')),(0,i.kt)("p",null,"Now that we have a method that initializes the MDS, we will add it to our ",(0,i.kt)("inlineCode",{parentName:"p"},"RelyingPartyInstance")," class for use in both our ",(0,i.kt)("inlineCode",{parentName:"p"},"RelyingParty")," configuration, and in other areas of our application. Note the highlighted lines in the sample below for the new additions to the initialization of our ",(0,i.kt)("inlineCode",{parentName:"p"},"RelyingPartyInstance"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'package com.yubicolabs.passkey_rp.services.passkey;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.annotation.PostConstruct;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Service;\n\nimport com.yubico.webauthn.RelyingParty;\nimport com.yubico.webauthn.data.AttestationConveyancePreference;\nimport com.yubico.webauthn.data.RelyingPartyIdentity;\nimport com.yubicolabs.passkey_rp.services.storage.StorageInstance;\n\nimport lombok.Getter;\n\npublic class RelyingPartyInstance {\n\n  @Getter\n  private RelyingParty relyingParty;\n\n  // highlight-start\n  @Getter\n  private Optional<FidoMetadataService> mds;\n  // highlight-end\n\n  @PostConstruct\n  private void setRPInstance() {\n    // highlight-start\n    /**\n     * Initialize the mds variable\n     */\n    FidoMetadataService initMDS = resolveAttestationTrustSource();\n    this.mds = Optional.ofNullable(initMDS);\n    // highlight-end\n\n    this.relyingParty = RelyingParty.builder()\n        .identity(generateIdentity())\n        .credentialRepository(storageInstance.getCredentialStorage())\n        .origins(generateOrigins())\n        .attestationConveyancePreference(\n            AttestationConveyancePreference.valueOf(System.getenv("RP_ATTESTATION_PREFERENCE")))\n        .allowUntrustedAttestation(Boolean.parseBoolean(System.getenv("RP_ALLOW_UNTRUSTED_ATTESTATION")))\n        // highlight-start\n        /**\n         * We allow this setting to be null, just in case the application does not\n         * want to leverage the MDS\n         * We also need to cast the object to `AttestationTrustSource`, which is the\n         * Interface that is leveraged by the initMDS class `FidoMetadataService`\n         */\n        .attestationTrustSource(Optional.ofNullable((AttestationTrustSource) initMDS))\n        // highlight-end\n        .validateSignatureCounter(true)\n        .build();\n  }\n}\n')),(0,i.kt)("h2",{id:"registration-response-method-changes"},"Registration response method changes"),(0,i.kt)("p",null,"The registration method will need to be changed in order to attempt to use an attestation statement sent during the credential registration."),(0,i.kt)("p",null,"The updates will be made to the ",(0,i.kt)("inlineCode",{parentName:"p"},"attestationResult")," method that was created in the previous topic on ",(0,i.kt)("a",{parentName:"p",href:"/docs/relying-party/reg-flow#implementation-1"},"relying party implementation guidance"),"."),(0,i.kt)("p",null,"The changes will be made to a method leveraged within our initial implementation, ",(0,i.kt)("inlineCode",{parentName:"p"},"buildCredentialDBO"),". This method is used to package the passkey information to store it in our credential repository."),(0,i.kt)("p",null,"The original version of the method is demonstrated in the flow below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'private CredentialRegistration buildCredentialDBO(PublicKeyCredentialCreationOptions request,\n    RegistrationResult result) {\n  return CredentialRegistration.builder()\n      .userIdentity(request.getUser())\n      .credentialNickname(Optional.of("My new credential"))\n      .registrationTime(clock.instant())\n      .lastUpdateTime(clock.instant())\n      .lastUsedTime(clock.instant())\n      .credential(RegisteredCredential.builder()\n          .credentialId(result.getKeyId().getId())\n          .userHandle(request.getUser().getId())\n          .publicKeyCose(result.getPublicKeyCose())\n          .signatureCount(result.getSignatureCount())\n          .build())\n      .iconURI(null)\n      .build();\n}\n')),(0,i.kt)("p",null,'As you can note, the credential is built using either information that came directly from the passkey itself, or using "hard-coded", or default values (in the case of ',(0,i.kt)("inlineCode",{parentName:"p"},"credentialNickname")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"iconURI"),")."),(0,i.kt)("p",null,"In the next example we will enhance this method in order to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"detect if attestation was sent along with the passkey"),(0,i.kt)("li",{parentName:"ul"},"if metadata can be inferred about the credential using the provided attestation statement")),(0,i.kt)("p",null,"The code sample below demonstrates an updated version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"buildCredentialDBO")," method that leverages our metadata service that was initialized earlier on this page."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'private CredentialRegistration buildCredentialDBO(PublicKeyCredentialCreationOptions request,\n    RegistrationResult result) {\n  Optional<MetadataStatement> maybeMetadataEntry = resolveAttestation(result);\n\n  String credentialName;\n  String iconURI;\n\n  /**\n   * We were able to correlate the attestation statement sent by our new passkey\n   * to an entry in our metadata service\n   */\n  if (maybeMetadataEntry.isPresent()) {\n    /**\n     * We will attempt to find the description and iconURI in the metadata statement\n     * Note, that your entry may be missing these values, or they were not provided by the vendor\n     * If this data is not present, then utilize the default values\n     */\n    credentialName = maybeMetadataEntry.get().getDescription().isPresent()\n        ? maybeMetadataEntry.get().getDescription().get()\n        : "My new passkey";\n    iconURI = maybeMetadataEntry.get().getIcon().isPresent()\n        ? maybeMetadataEntry.get().getIcon().get()\n        : null;\n  } else { // No attestation correlation made, provide our default values\n    credentialName = "My new passkey";\n    iconURI = null;\n  }\n\n  return CredentialRegistration.builder()\n      .userIdentity(request.getUser())\n      .credentialNickname(Optional.of(credentialName))\n      .registrationTime(clock.instant())\n      .lastUpdateTime(clock.instant())\n      .lastUsedTime(clock.instant())\n      .credential(RegisteredCredential.builder()\n          .credentialId(result.getKeyId().getId())\n          .userHandle(request.getUser().getId())\n          .publicKeyCose(result.getPublicKeyCose())\n          .signatureCount(result.getSignatureCount())\n          .build())\n      .iconURI(Optional.ofNullable(iconURI))\n      .build();\n}\n\n/**\n * Determine if the registration result can resolve to a entry in the MDS\n *\n * @param result newly created passkey for the user\n * @return Optional MetadataStatement object if present\n *         null otherwise\n */\nprivate Optional<MetadataStatement> resolveAttestation(RegistrationResult result) {\n  /**\n   * If the MDS was not initialized, then we can\'t resolve the attestation statement, so return null\n   * If the result did not send attestation, then there\'s nothing to resolve, return null\n   */\n  if (relyingPartyInstance.getMds().isPresent() && result.isAttestationTrusted()) {\n    /**\n     * Search the MDS for the specific entry that correlates to our passkey\n     */\n    Set<MetadataBLOBPayloadEntry> entries = relyingPartyInstance.getMds().get().findEntries(result);\n\n    /**\n     * If an entry was found, return it\n     */\n    if (entries.size() != 0) {\n      Optional<MetadataStatement> entry = entries.stream().findFirst()\n          .flatMap(MetadataBLOBPayloadEntry::getMetadataStatement);\n\n      return entry;\n    }\n    // No entry found, return null\n    return Optional.ofNullable(null);\n  } else {\n    return Optional.ofNullable(null);\n  }\n}\n')),(0,i.kt)("h2",{id:"credential-repository-considerations"},"Credential repository considerations"),(0,i.kt)("p",null,"Ensure that your credential repository is updated to reflect the metadata information that you wish to utilize or present to the user. For instance below is the table schema that is utilized for our credential repository."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE credential_registrations (\n  id BIGINT,\n  credential TEXT, --JSON string containing the credential\n  credentialid TEXT, --base64url string denoting the ID of the credential\n  credential_nickname TEXT,\n  last_update_time BIGINT,\n  last_used_time BIGINT,\n  registration_time BIGINT,\n  user_handle TEXT --base64url string denoting the ID of the user\n  iconURI TEXT\n);\n")),(0,i.kt)("p",null,"Note our inclusion of the ",(0,i.kt)("inlineCode",{parentName:"p"},"credential_nickname")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"iconURI"),", which was the metadata that we captured in the previous code example."),(0,i.kt)("p",null,"The FIDO MDS contains more information than just authenticator name, and icon. If you wish to utilize this data, ensure that it's reflected in your table schema, and database object model/class in your Java application. Otherwise it will not be captured to be utilized later."),(0,i.kt)("p",null,"You could attempt to save the full ",(0,i.kt)("inlineCode",{parentName:"p"},"RegistrationResult")," (passkey sent to finalize registration), and attempt to use it to gather attestation data at a later date."))}p.isMDXComponent=!0}}]);