"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[483],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4875:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:2},o="Data sources and RP configurations",s={unversionedId:"relying-party/config-and-data",id:"relying-party/config-and-data",title:"Data sources and RP configurations",description:"In this section we are going to outline some essential utilities that are needed in order to perform passkey functions. This will provide the foundations for our relying party (RP) application that will ensure that the requests/responses from the API are compliant with mainstream platform implementations, and that our application can interact with some form of data source.",source:"@site/docs/relying-party/config-and-data.md",sourceDirName:"relying-party",slug:"/relying-party/config-and-data",permalink:"/docs/relying-party/config-and-data",draft:!1,editUrl:"https://github.com/YubicoLabs/passkey-workshop/tree/main/docs/docs/relying-party/config-and-data.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"API definition",permalink:"/docs/relying-party/api-def"},next:{title:"Registration flows",permalink:"/docs/relying-party/reg-flow"}},l={},c=[{value:"Data sources",id:"data-sources",level:2},{value:"Tables",id:"tables",level:3},{value:"Attestation request repository",id:"attestation-request-repository",level:3},{value:"Database object",id:"database-object",level:4},{value:"Interface",id:"interface",level:4},{value:"Assertion request repository",id:"assertion-request-repository",level:3},{value:"Database object",id:"database-object-1",level:4},{value:"Interface",id:"interface-1",level:4},{value:"Credential repository",id:"credential-repository",level:3},{value:"Database object",id:"database-object-2",level:4},{value:"Interface",id:"interface-2",level:4},{value:"RP configurations",id:"rp-configurations",level:2}],p={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"data-sources-and-rp-configurations"},"Data sources and RP configurations"),(0,r.kt)("p",null,"In this section we are going to outline some essential utilities that are needed in order to perform passkey functions. This will provide the foundations for our relying party (",(0,r.kt)("strong",{parentName:"p"},"RP"),") application that will ensure that the requests/responses from the API are compliant with mainstream platform implementations, and that our application can interact with some form of data source."),(0,r.kt)("h2",{id:"data-sources"},"Data sources"),(0,r.kt)("p",null,"Let's first dive into the data sources used in this project, and the interfaces that are leveraged."),(0,r.kt)("h3",{id:"tables"},"Tables"),(0,r.kt)("p",null,"Our example will need to leverage three different tables."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/architecture/relying-party#credential-repository"},"Credential repository")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/architecture/relying-party#attestation-request-repository"},"Attestation request repository")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/architecture/relying-party#assertion-request-repository"},"Assertion request repository"))),(0,r.kt)("p",null,"These tables were explained in the architecture section. Please click the links above for more information."),(0,r.kt)("p",null,"Note, that our implementation leverages a MySQL database. To help with extensibility, we have provided an interface that can be used to add your preferred database. The idea is that these are the standard methods you are going to need in order to facilitate passkey transactions."),(0,r.kt)("h3",{id:"attestation-request-repository"},"Attestation request repository"),(0,r.kt)("h4",{id:"database-object"},"Database object"),(0,r.kt)("p",null,"Below is an example of the object that is used to store data in the MySQL server,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'package com.yubicolabs.passkey_rp.models.dbo.mysql;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\nimport javax.persistence.Table;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n\n@Builder\n@Entity\n@NoArgsConstructor\n@AllArgsConstructor\n@Table(name = "attestation_requests")\npublic class AttestationOptionsDBO {\n  @Getter\n  @Column(columnDefinition = "text")\n  String attestationRequest;\n\n  @Getter\n  @Setter\n  Boolean isActive;\n\n  @Getter\n  @Column(columnDefinition = "text")\n  String requestId;\n\n  @Id\n  @GeneratedValue(strategy = GenerationType.AUTO)\n  private Long id;\n}\n')),(0,r.kt)("p",null,"Note that the only field that should be altered is the ",(0,r.kt)("inlineCode",{parentName:"p"},"isActive")," property. This will indicate if this request is still live. You should invalidate this item if the request has been used, or if some timeout period has lapsed."),(0,r.kt)("p",null,"The attestation request will relate to the ",(0,r.kt)("inlineCode",{parentName:"p"},"PublicKeyCredentialCreationOptions"),", that will be discussed in a later section. For now just note that it's a complex object that will be stored as a JSON string."),(0,r.kt)("h4",{id:"interface"},"Interface"),(0,r.kt)("p",null,"Below is an example of the interface that is used to perform actions in the database."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"package com.yubicolabs.passkey_rp.interfaces;\n\nimport java.util.Optional;\n\nimport com.yubico.webauthn.data.PublicKeyCredentialCreationOptions;\nimport com.yubicolabs.passkey_rp.models.common.AttestationOptions;\n\npublic interface AttestationRequestStorage {\n  /**\n   * Add a new registration request to storage\n   *\n   * @param request created registration request to track for incoming\n   *                registration\n   * @return true if the registration was added to storage, and false\n   *         otherwise\n   */\n  public Boolean insert(PublicKeyCredentialCreationOptions request, String requestId);\n\n  /**\n   * Invalidate the designated request to prevent replay attacks from duplicate\n   * registrations with the same request ID\n   *\n   * @param requestID ID of the request to invalidate\n   * @return true if the request was successfully invalidated, false otherwise\n   */\n  public Boolean invalidate(String requestID);\n\n  /**\n   * Get a registration request if it exists in storage\n   *\n   * @param requestID ID of the request to retrieve\n   * @return Optional object that may include a registration request if found,\n   *         empty otherwise\n   */\n  public Optional<AttestationOptions> getIfPresent(String requestID);\n}\n")),(0,r.kt)("h3",{id:"assertion-request-repository"},"Assertion request repository"),(0,r.kt)("h4",{id:"database-object-1"},"Database object"),(0,r.kt)("p",null,"Below is an example of the object that is used to store data in the MySQL server,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'package com.yubicolabs.passkey_rp.models.dbo.mysql;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\nimport javax.persistence.Table;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n\n@Builder\n@Entity\n@NoArgsConstructor\n@AllArgsConstructor\n@Table(name = "assertion_requests")\npublic class AssertionOptionsDBO {\n\n  @Getter\n  @Column(columnDefinition = "text")\n  String assertionRequest;\n\n  @Getter\n  @Setter\n  Boolean isActive;\n\n  @Getter\n  @Column(columnDefinition = "text")\n  String requestId;\n\n  @Id\n  @GeneratedValue(strategy = GenerationType.AUTO)\n  private Long id;\n}\n\n')),(0,r.kt)("p",null,"Note that the only field that should be altered is the ",(0,r.kt)("inlineCode",{parentName:"p"},"isActive")," property. This will indicate if this request is still live. You should invalidate this item if the request has been used, or if some timeout period has lapsed."),(0,r.kt)("p",null,"The assertion request will relate to the ",(0,r.kt)("inlineCode",{parentName:"p"},"PublicKeyCredentialRequestOptions"),", that will be discussed in a later section. For now just note that it's a complex object that will be stored as a JSON string."),(0,r.kt)("h4",{id:"interface-1"},"Interface"),(0,r.kt)("p",null,"Below is an example of the interface that is used to perform actions in the database."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"package com.yubicolabs.passkey_rp.interfaces;\n\nimport java.util.Optional;\n\nimport com.yubico.webauthn.AssertionRequest;\nimport com.yubicolabs.passkey_rp.models.common.AssertionOptions;\n\npublic interface AssertionRequestStorage {\n  /**\n   * Add a new assertion request to storage\n   *\n   * @param request created registration request to track for incoming\n   *                registration\n   * @return true if the request was successfully added, false otherwise\n   */\n  public Boolean insert(AssertionRequest request, String requestId);\n\n  /**\n   * Invalidate the designated request to prevent replay attacks from duplicate\n   * authentication with the same request ID\n   *\n   * @param requestID ID of the request to invalidate\n   * @return true if the request was successfully invalidated, false otherwise\n   */\n  public Boolean invalidate(String requestID);\n\n  /**\n   * Get a request by ID\n   *\n   * @param requestID ID of the request to retrieve\n   * @return Optional object that contains an assertion request if present, empty\n   *         otherwise\n   */\n  public Optional<AssertionOptions> getIfPresent(String requestID);\n}\n")),(0,r.kt)("h3",{id:"credential-repository"},"Credential repository"),(0,r.kt)("h4",{id:"database-object-2"},"Database object"),(0,r.kt)("p",null,"Below is an example of the object that is used to store credentials in the MySQL server,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'package com.yubicolabs.passkey_rp.models.dbo.mysql;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\nimport javax.persistence.Table;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n\n@Builder\n@Entity\n@NoArgsConstructor\n@AllArgsConstructor\n@Table(name = "credential_registrations")\npublic class CredentialRegistrationDBO {\n\n  @Getter\n  @Column(columnDefinition = "text")\n  String userHandle;\n\n  @Getter\n  @Column(columnDefinition = "text")\n  String credentialID;\n\n  @Getter\n  @Column(columnDefinition = "text")\n  String userIdentity;\n\n  @Getter\n  @Setter\n  @Column(columnDefinition = "text")\n  String credentialNickname;\n\n  @Getter\n  long registrationTime;\n\n  @Getter\n  long lastUsedTime;\n\n  @Getter\n  long lastUpdateTime;\n\n  @Getter\n  @Column(columnDefinition = "text")\n  String credential;\n\n  @Id\n  @GeneratedValue(strategy = GenerationType.AUTO)\n  private Long id;\n}\n')),(0,r.kt)("p",null,"The property ",(0,r.kt)("inlineCode",{parentName:"p"},"credential")," will be the field that stores the actual passkey itself. Some of the other fields like ",(0,r.kt)("inlineCode",{parentName:"p"},"credentialId")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"userHandle")," can be inferred from the data encoded in the ",(0,r.kt)("inlineCode",{parentName:"p"},"credential")," property, but are highlighted to help improve searchability of credentials from your application. Many operations may need to either find an individual credential by ID, or group all of the credentials by ",(0,r.kt)("inlineCode",{parentName:"p"},"userHandle"),"."),(0,r.kt)("p",null,"The time based properties, ",(0,r.kt)("inlineCode",{parentName:"p"},"registrationTime"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"lastUsedTime")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"lastUpdateTime"),", are not required, but are generally best practices that can be used for reporting."),(0,r.kt)("p",null,"Note the only option that is allowed to be updated is the ",(0,r.kt)("inlineCode",{parentName:"p"},"credentialNickname"),". As discussed in an earlier section, you should not allow users to edit the passkey (credential) directly, but instead provide some identifier that they can use to help with credential management"),(0,r.kt)("h4",{id:"interface-2"},"Interface"),(0,r.kt)("p",null,"Below is an example of the interface that is used to perform actions in the database."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"package com.yubicolabs.passkey_rp.interfaces;\n\nimport java.util.Collection;\n\nimport com.yubico.webauthn.CredentialRepository;\nimport com.yubico.webauthn.data.ByteArray;\nimport com.yubicolabs.passkey_rp.models.common.CredentialRegistration;;\n\npublic interface CredentialStorage extends CredentialRepository {\n  /**\n   * Adds a new credential for a user into the Credential Repository\n   *\n   * @param registration credential to be stored for the used\n   * @return true indicates the credential was successfully created, false\n   *         otherwise\n   */\n  public Boolean addRegistration(CredentialRegistration registration);\n\n  /**\n   * Gets all registrations that belong to a username\n   *\n   * @param username denotes the user whose credential will be returned\n   * @return collection of registrations belonging to a defined username\n   */\n  public Collection<CredentialRegistration> getRegistrationsByUsername(String username);\n\n  /**\n   * Gets all registrations that belong to a userHandle\n   *\n   * @param userHandle denotes the user whose credentials will be returned\n   * @return collection of registrations belonging to a defined user handle\n   */\n  public Collection<CredentialRegistration> getRegistrationsByUserHandle(ByteArray userHandle);\n\n  /**\n   * Gets all credentials associated to a credential ID\n   *\n   * @param credentialId denotes the credentialId to search for\n   * @return collection of all credentials with the credential ID\n   */\n  public Collection<CredentialRegistration> getByCredentialId(ByteArray credentialId);\n\n  /**\n   * Determines if a user has a credential in the credential repository\n   *\n   * @param username denotes the user to be searched for\n   * @return true if the user has a credential, false otherwise\n   */\n  public Boolean userExists(String username);\n\n  /**\n   * Removes a credential from the credential repository\n   *\n   * @param credentialId ID of the credential to be removed\n   * @param userHandle   the user handle of the user attempting to make the\n   *                     request\n   * @return true if the credential was successfully removed, false otherwise\n   */\n  public Boolean removeRegistration(ByteArray credentialId, ByteArray userHandle);\n\n  /**\n   * Updates the nickname of a specific credential\n   *\n   * @param nickname     new nickname to be given to a credential\n   * @param credentialId ID of the credential to be renamed\n   * @return true if the credential was successfully renamed, false otherwise\n   */\n  public Boolean updateCredentialNickname(ByteArray credentialId, String newNickname);\n}\n")),(0,r.kt)("h2",{id:"rp-configurations"},"RP configurations"),(0,r.kt)("p",null,"The next step is to set the common configurations for your relying party. This means setting the RP ID that is used to identify the specific relying party, the application's name, where to find the credential repository, and the web domains/origins that are allowed to create passkeys for this site."),(0,r.kt)("p",null,"In the java-webauthn-server, this is packaged as a ",(0,r.kt)("inlineCode",{parentName:"p"},"RelyingParty")," object. This ",(0,r.kt)("inlineCode",{parentName:"p"},"RelyingParty")," instance will be used throughout the application in order to create and process attestation and assertion requests."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"RelyingParty")," instance can be declared as such"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'package com.yubicolabs.passkey_rp.services.passkey;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.annotation.PostConstruct;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Service;\n\nimport com.yubico.webauthn.RelyingParty;\nimport com.yubico.webauthn.data.AttestationConveyancePreference;\nimport com.yubico.webauthn.data.RelyingPartyIdentity;\nimport com.yubicolabs.passkey_rp.services.storage.StorageInstance;\n\nimport lombok.Getter;\n\n@Service\n@Scope("singleton")\npublic class RelyingPartyInstance {\n\n  @Getter\n  @Autowired\n  private StorageInstance storageInstance;\n\n  @Getter\n  private RelyingParty relyingParty;\n\n  @PostConstruct\n  private void setRPInstance() {\n    this.relyingParty = RelyingParty.builder()\n        .identity(generateIdentity())\n        .credentialRepository(storageInstance.getCredentialStorage())\n        .origins(generateOrigins())\n        .attestationConveyancePreference(\n            AttestationConveyancePreference.valueOf(System.getenv("RP_ATTESTATION_PREFERENCE")))\n        .allowUntrustedAttestation(Boolean.parseBoolean(System.getenv("RP_ALLOW_UNTRUSTED_ATTESTATION")))\n        .attestationTrustSource(null) // Set this field to null, we will cover this in detail in the section on attestation\n        .validateSignatureCounter(true)\n        .build();\n  }\n\n  private RelyingPartyIdentity generateIdentity() {\n    /*\n     * Get RP ID and Name from env variables\n     */\n    String rpID = System.getenv("RP_ID");\n    String rpName = System.getenv("RP_NAME");\n\n    return RelyingPartyIdentity.builder()\n        .id(rpID)\n        .name(rpName)\n        .build();\n  }\n\n  private Set<String> generateOrigins() {\n    /*\n     * Get origins list value from env variables\n     */\n\n    String originsVal = System.getenv("RP_ALLOWED_ORIGINS");\n\n    /*\n     * Split the origins list by comma (as noted by the shell script)\n     */\n\n    String[] originsList = originsVal.split(",");\n\n    /*\n     * Iterate through origins list\n     */\n\n    Set<String> allowedOrigins = new HashSet<String>();\n\n    for (int i = 0; i < originsList.length; i++) {\n      allowedOrigins.add("https://" + originsList[i]);\n    }\n\n    return allowedOrigins;\n  }\n}\n\n')),(0,r.kt)("p",null,"Note in our example that some of the fields are driven by environment variables. These variables are created during the ",(0,r.kt)("a",{parentName:"p",href:"/docs/deploy"},"deployment phase"),". If you have been following along with this guide, then they should be utilizing default values. Later sections may change these values based on the use case."),(0,r.kt)("p",null,"Note the use of the ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageInstance")," reference declared at the top of the code sample. This object will contain your various data sources declared in the previous section. Behind the scenes this object is comprised of various factories that initialize, and delegate the database provider that should be used, that all adhere to the interfaces mentioned above. At this moment, you are most likely leveraging the MySQL server included in this project. For more technical information, please see the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/YubicoLabs/passkey-workshop/blob/main/examples/relyingParties/java-spring/src/main/java/com/yubicolabs/passkey_rp/services/storage/StorageInstance.java"},"source code"),"."))}d.isMDXComponent=!0}}]);