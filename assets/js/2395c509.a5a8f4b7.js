"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[745],{7269:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"architecture/relying-party","title":"Relying party","description":"A relying party (RP) is an industry term that is used to describe an application that is used to verify the identity of an entity through authentication, and to provide the correct level of authorization based on the permissions granted to the entity.","source":"@site/docs/architecture/relying-party.md","sourceDirName":"architecture","slug":"/architecture/relying-party","permalink":"/passkey-workshop/docs/architecture/relying-party","draft":false,"unlisted":false,"editUrl":"https://github.com/YubicoLabs/passkey-workshop/tree/main/docs/docs/architecture/relying-party.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Client application","permalink":"/passkey-workshop/docs/architecture/client-app"},"next":{"title":"Deploy project","permalink":"/passkey-workshop/docs/deploy"}}');var a=i(2467),r=i(8453);const s={sidebar_position:3},o="Relying party",l={},h=[{value:"Build vs buy",id:"build-vs-buy",level:2},{value:"Components in our RP example",id:"components-in-our-rp-example",level:2},{value:"Application layer",id:"application-layer",level:3},{value:"Identity provider",id:"identity-provider",level:3},{value:"Credential repository",id:"credential-repository",level:3},{value:"Credential repository",id:"credential-repository-1",level:4},{value:"Attestation request repository",id:"attestation-request-repository",level:4},{value:"Assertion request repository",id:"assertion-request-repository",level:4},{value:"Metadata repository",id:"metadata-repository",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"relying-party",children:"Relying party"})}),"\n",(0,a.jsx)(t.p,{children:"A relying party (RP) is an industry term that is used to describe an application that is used to verify the identity of an entity through authentication, and to provide the correct level of authorization based on the permissions granted to the entity."}),"\n",(0,a.jsx)(t.p,{children:"In terms of passkey applications, this is the component that will manage credentials, verify and issue authentication challenges, and grant access when appropriate. While relying parties for passkey applications facilitate similar ceremonies, they are not one size fits all, and should reflect the security policies set by business or regulatory requirements. In this guide when we refer to the backend application, note that we are only referencing the responsibilities of the relying party."}),"\n",(0,a.jsx)(t.h2,{id:"build-vs-buy",children:"Build vs buy"}),"\n",(0,a.jsx)(t.p,{children:"It is not always required to develop each component of an RP. There are many services that provide passkey/webauthn functionality out-of-the-box (such as Okta, or Azure B2C)."}),"\n",(0,a.jsx)(t.p,{children:"The determination of build vs buy should be made by evaluating options against your security policies, use case, and developer resources. Some use cases may work well using the out of the box features of a service. Other use cases may require more specific functionality based on your security policies that may leave you with no choice but to develop your own solution."}),"\n",(0,a.jsx)(t.p,{children:"The examples in the workshop are a demonstration of a fully custom built solution; or in more accurate terms, a solution comprised of different mainstream services that work together to create a passkey experience. Note that the components used in our examples are not meant to act as our recommended technologies; rather, we are trying to demonstrate that a passkey application, if architected correctly, can be built using technologies familiar to many developers."}),"\n",(0,a.jsx)(t.p,{children:"Once you have grasped the fundamental concepts, feel free to leverage the interfaces defined in our application to integrate your preferred technologies."}),"\n",(0,a.jsx)(t.h2,{id:"components-in-our-rp-example",children:"Components in our RP example"}),"\n",(0,a.jsx)(t.h3,{id:"application-layer",children:"Application layer"}),"\n",(0,a.jsxs)(t.p,{children:["Our application was developed using the Java Spring-Boot framework. This application leverages ",(0,a.jsx)(t.a,{href:"https://github.com/Yubico/java-webauthn-server",children:"Yubico's java-webauthn-server library"}),", which comes with pre-built methods and classes to help you ingest and process WebAuthn requests."]}),"\n",(0,a.jsxs)(t.p,{children:["RPs are not only limited to using Java, and Yubico's library. ",(0,a.jsx)(t.a,{href:"https://github.com/herrjemand/awesome-webauthn",children:"This page"})," will provide different alternatives for libraries and SDKs that can be used to ease your app development."]}),"\n",(0,a.jsx)(t.h3,{id:"identity-provider",children:"Identity provider"}),"\n",(0,a.jsxs)(t.p,{children:["Our example leverages ",(0,a.jsx)(t.a,{href:"https://www.keycloak.org/",children:"Keycloak"})," as our identity provider, and authorization server."]}),"\n",(0,a.jsx)(t.p,{children:"It's important to note that Keycloak provides WebAuthn functionality out of the box. With that said our implementation leverages a custom Keycloak authentication SPI, that connects to our application layer component (mentioned above). We took this approach in-order to extend our application logic beyond what is provided in Keycloak."}),"\n",(0,a.jsx)(t.h3,{id:"credential-repository",children:"Credential repository"}),"\n",(0,a.jsx)(t.p,{children:"Our application leverages MySQL as the database leveraged by the application. Below you will find the schemas that are used to define the different tables in our database"}),"\n",(0,a.jsx)(t.h4,{id:"credential-repository-1",children:"Credential repository"}),"\n",(0,a.jsx)(t.p,{children:"The credential repository is the table that will store the passkeys that are created by the user. Keep in mind that these are the public keys that correspond to the private key, managed by your authenticator."}),"\n",(0,a.jsx)(t.p,{children:"One of the main advantages that passkeys have over passwords is that a compromise of this table is not as severe, as would be the case when it contained passwords. The public keys are useless without the corresponding private key."}),"\n",(0,a.jsx)(t.p,{children:"Note that many of the fields are noted as TEXT. Where noted, this is either a base64url string denoting an identifier, or a json string that contains data used by the application."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE credential_registrations (\n  id BIGINT,\n  credential TEXT, --JSON string containing the credential\n  credentialid TEXT, --base64url string denoting the ID of the credential\n  credential_nickname TEXT,\n  last_update_time BIGINT,\n  last_used_time BIGINT,\n  registration_time BIGINT,\n  user_handle TEXT --base64url string denoting the ID of the user\n  iconURI TEXT\n);\n"})}),"\n",(0,a.jsx)(t.h4,{id:"attestation-request-repository",children:"Attestation request repository"}),"\n",(0,a.jsx)(t.p,{children:"The attestation request repository will store the requests that have been issued by the relying party for the creation of a new passkey. This is important to implement as you will want a mechanism to ensure only valid registration requests are sent to your application. This will allow you to:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Block unprompted registrations"}),"\n",(0,a.jsx)(t.li,{children:"Block registrations that send a challenge that does not match what was previously issued"}),"\n",(0,a.jsx)(t.li,{children:"Invalidate registration requests that have been used or have exceeded a timeout period"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE attestation_requests (\n  id BIGINT,\n  attestation_request TEXT, --JSON string containing the PublicKeyCredentialCreationOptions\n  is_active BOOLEAN,\n  request_id TEXT --base64url string denoting the ID of the request\n);\n"})}),"\n",(0,a.jsx)(t.h4,{id:"assertion-request-repository",children:"Assertion request repository"}),"\n",(0,a.jsx)(t.p,{children:"The assertion request repository will store the requests that have been issued by the relying party for authenticating with a passkey. You will want a mechanism to store and refer to authentication requests that have been sent. This will enable you to:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Block unprompted authentications"}),"\n",(0,a.jsx)(t.li,{children:"Block authentications that utilized a challenge that does not match what was issued"}),"\n",(0,a.jsx)(t.li,{children:"Refer to the original challenge that was issued in order to verify signed challenges"}),"\n",(0,a.jsx)(t.li,{children:"Invalidate authentication requests that have been used or have exceeded a timeout period"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE assertion_requests (\n  id BIGINT,\n  assertion_request TEXT, --JSON string containing the PublicKeyCredentialCreationOptions\n  is_active BOOLEAN,\n  request_id TEXT --base64url string denoting the ID of the request\n);\n"})}),"\n",(0,a.jsx)(t.h3,{id:"metadata-repository",children:"Metadata repository"}),"\n",(0,a.jsxs)(t.p,{children:["This example leverages the ",(0,a.jsx)(t.a,{href:"https://fidoalliance.org/metadata/",children:"FIDO Metadata Service (MDS)"}),", which is a collection of metadata for authenticators. The MDS can be used to evaluate the root of trust sent with a credential during registration in order to identify the device, and correlate it to a metadata entry containing a variety of different data on the authenticator."]}),"\n",(0,a.jsx)(t.p,{children:"The repository is offered in the form of a BLOB hosted on a FIDO Alliance resource. If your application is connected to an external network, then you can download the BLOB using a cURL request, or you can download and self-host it for non-public facing resources hosted in your environment."}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.a,{href:"https://github.com/Yubico/java-webauthn-server",children:"Yubico java-webauthn-server library"})," includes support for the MDS, where you are able to download the BLOB, and validate attestation statements."]})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>o});var n=i(6540);const a={},r=n.createContext(a);function s(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);