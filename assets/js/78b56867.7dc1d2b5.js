"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5058],{5680:(e,t,n)=>{n.d(t,{xA:()=>l,yg:()=>y});var a=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),c=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=c(e.components);return a.createElement(d.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=c(n),g=r,y=u["".concat(d,".").concat(g)]||u[g]||p[g]||i;return n?a.createElement(y,o(o({ref:t},l),{},{components:n})):a.createElement(y,o({ref:t},l))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=g;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},775:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(8168),r=(n(6540),n(5680));const i={sidebar_position:5},o="Advanced Protection",s={unversionedId:"high_assurance/relying_party/advanced_protection",id:"high_assurance/relying_party/advanced_protection",title:"Advanced Protection",description:"This section will cover the topic of advanced protection.",source:"@site/docs/high_assurance/relying_party/advanced_protection.md",sourceDirName:"high_assurance/relying_party",slug:"/high_assurance/relying_party/advanced_protection",permalink:"/passkey-workshop/docs/high_assurance/relying_party/advanced_protection",draft:!1,editUrl:"https://github.com/YubicoLabs/passkey-workshop/tree/main/docs/docs/high_assurance/relying_party/advanced_protection.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Banking Application",permalink:"/passkey-workshop/docs/high_assurance/relying_party/banking_api"},next:{title:"Client application",permalink:"/passkey-workshop/docs/high_assurance/client_application"}},d={},c=[],l={toc:c},u="wrapper";function p(e){let{components:t,...n}=e;return(0,r.yg)(u,(0,a.A)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"advanced-protection"},"Advanced Protection"),(0,r.yg)("p",null,"This section will cover the topic of advanced protection."),(0,r.yg)("p",null,"Advanced protection allows a user to declare that they want their account to be secured by the highest degree of assurance regardless of other convenience mechanisms.\nIn this section we will outline how this is enabled from our Relying Party application."),(0,r.yg)("h1",{id:"overview"},"Overview"),(0,r.yg)("p",null,"Advanced protection is implemented as a user setting that can be enabled.\nWhen enabled, any passkey used to authenticate to the banking application must be stored on a security key.\nWe need several changes to our banking application to support advanced protection, which are described below."),(0,r.yg)("h1",{id:"api-definition"},"API definition"),(0,r.yg)("p",null,"A new API method ",(0,r.yg)("inlineCode",{parentName:"p"},"/user/advanced-protection/{userHandle}")," is added to retrieve (GET) or set (PUT) the advanced protection status of a user.\nThe user's ",(0,r.yg)("inlineCode",{parentName:"p"},"userHandle")," is supplied as a path parameter."),(0,r.yg)("p",null,"If you deployed the banking application on ",(0,r.yg)("inlineCode",{parentName:"p"},"localhost"),", you can find its OpenAPI definition ",(0,r.yg)("a",{parentName:"p",href:"http://localhost:8080/"},"here"),"."),(0,r.yg)("h1",{id:"data-sources"},"Data sources"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"passkeyStorage")," database needs to store the advanced protection status for every account."),(0,r.yg)("p",null,"This calls for a new attribute in the ",(0,r.yg)("inlineCode",{parentName:"p"},"account")," table:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE\n    account (\n        ...\n        advanced_protection BOOL DEFAULT FALSE,\n    )\n")),(0,r.yg)("p",null,"as well as a separate ",(0,r.yg)("inlineCode",{parentName:"p"},"advanced_protection_status")," table:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE\n    advanced_protection_status (\n        id BIGINT NOT NULL AUTO_INCREMENT,\n        user_handle NVARCHAR(256) NOT NULL,\n        is_advanced_protection BOOL DEFAULT FALSE,\n        PRIMARY KEY (id)\n    );\n")),(0,r.yg)("h1",{id:"registration"},"Registration"),(0,r.yg)("p",null,"During registration, we need to check whether advanced protection is enabled so we can decide if a credential (i.e. a passkey) can be added."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'  public AttestationResultResponse attestationResult(AttestationResultRequest response) throws Exception {\n\n  ...\n\n\n      if (!maybeUserInAdvancedProtection.isPresent()) {\n        relyingPartyInstance\n          .getStorageInstance()\n          .getAdvancedProtectionStatusStorage()\n          .insert(AdvancedProtectionStatus.builder()\n                .userHandle(options.getAttestationRequest().getUser().getId().getBase64Url())\n                .isAdvancedProtection(false)\n                .build());\n      } else {\n        if (relyingPartyInstance\n            .getStorageInstance()\n            .getAdvancedProtectionStatusStorage()\n            .getIfPresent(options.getAttestationRequest().getUser().getId().getBase64Url())\n            .get()\n            .isAdvancedProtection() && !newCred.isAttestationTrusted()) {\n          throw new Exception(\n              "This credential cannot be registered as you are enrolled in advanced protection. All new registrations should be made using a security key");\n        }\n      }\n}\n')),(0,r.yg)("p",null,"Next, we need to introduce methods to retrieve the advanced protection status of a specific user (identified by its ",(0,r.yg)("inlineCode",{parentName:"p"},"userHandle"),"):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'\n  public AdvancedProtection getAdvancedProtectionStatus(String userHandle) throws Exception {\n    try {\n      Optional<AdvancedProtectionStatus> maybeStatus =\n        relyingPartyInstance\n          .getStorageInstance()\n          .getAdvancedProtectionStatusStorage()\n          .getIfPresent(userHandle);\n\n      if (maybeStatus.isPresent()) {\n        return AdvancedProtection\n                .builder()\n                .userHandle(maybeStatus.get().getUserHandle())\n                .enabled(maybeStatus.get().isAdvancedProtection())\n                .build();\n      } else {\n        throw new Exception("This resource does not exist");\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Exception("There was an issue getting the advanced protection status for the user");\n    }\n  }\n')),(0,r.yg)("p",null,"To update a user's advanced protection status, we first need to check wether the user is eligible for advanced protection:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'  public AdvancedProtection updateAdvancedProtectionStatus(String userHandle,\n      UpdateAdvancedProtectionStatusRequest updateAdvancedProtectionStatusRequest) throws Exception {\n    try {\n      /**\n       * Check if the user is eligible for advanced protection\n       */\n      if (updateAdvancedProtectionStatusRequest.getEnabled()) {\n        int numberOfHighAssuranceCredentials = relyingPartyInstance.getStorageInstance().getCredentialStorage()\n            .getRegistrationsByUserHandle(ByteArray.fromBase64Url(userHandle)).stream()\n            .filter(credential -> credential.isHighAssurance()).collect(Collectors.toList()).size();\n\n        if (numberOfHighAssuranceCredentials < 2) {\n          throw new Exception("The user does not qualify for advanced protection status");\n        }\n      }\n\n      boolean didUpdate = relyingPartyInstance.getStorageInstance().getAdvancedProtectionStatusStorage()\n          .setAdvancedProtection(userHandle, updateAdvancedProtectionStatusRequest.getEnabled());\n\n      if (didUpdate) {\n        // No need to check optional, we know the record exists\n        AdvancedProtectionStatus updated = relyingPartyInstance.getStorageInstance()\n            .getAdvancedProtectionStatusStorage().getIfPresent(userHandle).get();\n        /*\n         * If true, go into credential registrations, and set all low assurance enabled\n         * credentials as disabled\n         *\n         * If false, go into credential registrations, and set all the disabled\n         * credentials as enabled\n         */\n\n        updateCredentialsForAdvancedProtection(updated.getUserHandle(), updated.isAdvancedProtection());\n\n        return AdvancedProtection.builder().userHandle(updated.getUserHandle())\n            .enabled(updated.isAdvancedProtection()).build();\n      } else {\n        throw new Exception("The items did not update correctly");\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Exception("There was an issue updating the advanced protection status for the user: " + e.getMessage());\n    }\n  }\n')),(0,r.yg)("p",null,"For any credential already registered, we need to check wether the credential is considered high assurance (i.e. stored on a security key).\nIf not, we need to disable the credential. Note that we do not delete the credential, as the credential can still be used when advanced protection is disabled again."),(0,r.yg)("p",null,"This handled by a new method ",(0,r.yg)("inlineCode",{parentName:"p"},"updateCredentialsForAdvancedProtection"),", with a boolean parameter indicating if advanced protection is enabled (switched on)\nor disabled (switched off)."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'\n  private void updateCredentialsForAdvancedProtection(String userHandle, Boolean isAdvancedProtection)\n      throws Exception {\n    Collection<CredentialRegistration> credList = relyingPartyInstance.getStorageInstance().getCredentialStorage()\n        .getRegistrationsByUserHandle(ByteArray.fromBase64Url(userHandle));\n    if (!credList.isEmpty()) {\n      credList.forEach(credential -> {\n        try {\n          if (!credential.isHighAssurance() && !credential.getState().stateEqual(StateEnum.DELETED)) {\n            relyingPartyInstance.getStorageInstance().getCredentialStorage()\n                .updateCredentialStatus(credential.getCredential().getCredentialId(),\n                    ByteArray.fromBase64Url(userHandle),\n                    isAdvancedProtection ? StateEnum.DISABLED : StateEnum.ENABLED);\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n\n      });\n    } else {\n      throw new Exception("This user has no credentials");\n    }\n  }\n')),(0,r.yg)("p",null,"The disabling of credentials itself is implemented with a separate method ",(0,r.yg)("inlineCode",{parentName:"p"},"updateCredentialStatus"),"."),(0,r.yg)("p",null,"A credential can have three status'"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"ENABLED")," - The credential is registered and can be used for authentication"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"DISABLED")," - The credential was deactivated when the user enrolled in advanced protection. The credential can be re-enabled, but for now can't be used for authentication"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"DELETED")," - The user deleted the credential and SHOULD NOT be re-enabled")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'  @Override\n  public Boolean updateCredentialStatus(ByteArray credentialId, ByteArray userHandle, StateEnum newState) {\n    try {\n      Collection<CredentialRegistration> credList = getRegistrationsByUserHandle(userHandle);\n\n      if (!credList.isEmpty()) {\n        CredentialRegistrationDBO dboItem = credentialRegistrationRepositoryMySql\n            .findByCredentialID(credentialId.getBase64Url()).get(0);\n\n        if (dboItem.getState().equals(StateEnum.DELETED.getValue())) {\n          throw new Exception("Cannot change the state of a deleted credential");\n        }\n\n        dboItem.setState(newState.getValue());\n\n        CredentialRegistrationDBO newDbo = credentialRegistrationRepositoryMySql.save(dboItem);\n\n        if (newDbo.getState().equals(newState.getValue())) {\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n      return false;\n    }\n  }\n')))}p.isMDXComponent=!0}}]);