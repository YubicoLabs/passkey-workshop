"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5489],{6086:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/passkey_arch-18c3a64c88d8e205bb926c7b485385ae.jpg"},6888:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"architecture/architecture-at-a-glance","title":"Architecture at a glance","description":"We will start by observing a high level architecture diagram of a standard passkey enabled application. This first diagram outlines the required components of our application. Please note that this diagram does NOT include the core functionality of your application, only the components necessary for passkey and authentication/authorization related actions","source":"@site/docs/architecture/architecture-at-a-glance.md","sourceDirName":"architecture","slug":"/architecture/architecture-at-a-glance","permalink":"/passkey-workshop/docs/architecture/architecture-at-a-glance","draft":false,"unlisted":false,"editUrl":"https://github.com/YubicoLabs/passkey-workshop/tree/main/docs/docs/architecture/architecture-at-a-glance.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Architecture","permalink":"/passkey-workshop/docs/category/architecture"},"next":{"title":"Client application","permalink":"/passkey-workshop/docs/architecture/client-app"}}');var n=i(2467),r=i(8453);const o={sidebar_position:1},s="Architecture at a glance",c={},l=[{value:"Components",id:"components",level:2},{value:"Authenticator",id:"authenticator",level:3},{value:"Client application",id:"client-application",level:3},{value:"Relying party",id:"relying-party",level:3},{value:"Application layer",id:"application-layer",level:4},{value:"Identity provider",id:"identity-provider",level:4},{value:"Credential repository",id:"credential-repository",level:4},{value:"Metadata repository",id:"metadata-repository",level:4}];function h(e){const t={h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"architecture-at-a-glance",children:"Architecture at a glance"})}),"\n",(0,n.jsxs)(t.p,{children:["We will start by observing a high level architecture diagram of a standard passkey enabled application. This first diagram outlines the required components of our application. Please note that this diagram does ",(0,n.jsx)(t.strong,{children:"NOT"})," include the core functionality of your application, only the components necessary for passkey and authentication/authorization related actions"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Passkey architecture diagram",src:i(6086).A+"",width:"1095",height:"550"})}),"\n",(0,n.jsx)(t.h2,{id:"components",children:"Components"}),"\n",(0,n.jsx)(t.p,{children:"Below is a summary of the primary components of a passkey application."}),"\n",(0,n.jsx)(t.h3,{id:"authenticator",children:"Authenticator"}),"\n",(0,n.jsx)(t.p,{children:"Device or software that will be used as a token to prove the user\u2019s identity. WebAuthn relies on public key encryption - the authenticator will issue public keys to applications during registration, and will then use the corresponding private key to sign challenges issued during authentication."}),"\n",(0,n.jsx)(t.p,{children:"Authenticators can come in the form of hardware and software. Examples of hardware based authenticators could include security keys where the private key is bound to the device, and cannot be extracted. Software based authenticators can be a combination of a device\u2019s TPM module and an application that allows the user to store their credentials in the cloud, to be used across their devices."}),"\n",(0,n.jsx)(t.h3,{id:"client-application",children:"Client application"}),"\n",(0,n.jsx)(t.p,{children:"The client application is the front end application utilized by your users. The primary use in passkey applications will be for users to complete their authentication and registration ceremonies."}),"\n",(0,n.jsx)(t.p,{children:"The experience offered by the client will have some variety depending on the user\u2019s use of the operating system and browser, but should ultimately still provide the same degree of security and usability, assuming the ecosystem supports passkeys."}),"\n",(0,n.jsx)(t.h3,{id:"relying-party",children:"Relying party"}),"\n",(0,n.jsx)(t.p,{children:"The relying party is the backend application that will facilitate the authentication and registration ceremonies in order to determine if the user should be allowed to access their requested resources. The relying party can be broken down into smaller sub-components that all play a part in managing users."}),"\n",(0,n.jsx)(t.h4,{id:"application-layer",children:"Application layer"}),"\n",(0,n.jsx)(t.p,{children:"The application layer will be responsible for the core business logic required to complete registration, authentication, and user/credential management operations. This component will primarily be invoked by API\u2019s for specific actions. The primary goal will be to issue registration and authentication ceremonies, using inputs from the identity provider, and by referencing credentials stored in the credential repository."}),"\n",(0,n.jsx)(t.h4,{id:"identity-provider",children:"Identity provider"}),"\n",(0,n.jsx)(t.p,{children:"This is the service that will allow your application to manage users, and issue authorization tokens (such as OAuth2) to access its resources. This can be an in-house built solution, or a solution purchased from a technology vendor."}),"\n",(0,n.jsx)(t.p,{children:"Regardless of the type of solution, it will either need to support passkeys (WebAuthn) or allow you to create a custom flow that can interact with your application layer to facilitate the registration, and authentication ceremonies."}),"\n",(0,n.jsx)(t.h4,{id:"credential-repository",children:"Credential repository"}),"\n",(0,n.jsx)(t.p,{children:"This is the repository of user credentials (public keys) that were sent to the relying party during registration, and leveraged during the authentication ceremony. An advantage of using passkeys rather than passwords is the severity of this repository being compromised is mitigated. This repository can operate by only storing the public key, credential IDs, and associated user handle. If this repository is leaked, an attacker cannot leverage the public keys, without access to the authenticator with the private key."}),"\n",(0,n.jsx)(t.h4,{id:"metadata-repository",children:"Metadata repository"}),"\n",(0,n.jsx)(t.p,{children:"This is an optional component of your relying party, but should be included as a best practice. A metadata repository will allow your application to identify the make and model of a registered authenticator, if permission was granted by the user during registration."}),"\n",(0,n.jsx)(t.p,{children:"On the surface level this data can help the user experience by helping users and administrators understand more details about their authenticator. Digging deeper, this repository can help you impose different degrees of authenticator management, in high assurance scenarios that require some control over what can and cannot register in your environment. More will be covered on this when we discuss attestation."}),"\n",(0,n.jsx)(t.p,{children:"The next few sections will provide more details around our implementation of these components, best practices, and general considerations."})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>s});var a=i(6540);const n={},r=a.createContext(n);function o(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);