"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5806],{1659:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/architecture-login-flow-cf87b9fabbd21bbc4b6c6bfc8edb05a4.png"},4596:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/architecture-f943e27ab565de4d8a89a1836f889f0a.png"},6103:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/architecture-components-41079e303706929524e7a9c485740c9b.png"},6214:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/architecture-stepup-2cfdbd7ffdd4e429b3ce70de384fb38b.png"},8126:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"high_assurance/architecture","title":"Architecture","description":"Our consumer bank scenario is illustrated by a sample application that will require step-up authentication for \\"high-risk\\" transactions.","source":"@site/docs/high_assurance/architecture.md","sourceDirName":"high_assurance","slug":"/high_assurance/architecture","permalink":"/passkey-workshop/docs/high_assurance/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/YubicoLabs/passkey-workshop/tree/main/docs/docs/high_assurance/architecture.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Assurance levels","permalink":"/passkey-workshop/docs/high_assurance/assurance"},"next":{"title":"Deploy example","permalink":"/passkey-workshop/docs/high_assurance/deploy"}}');var i=n(2467),a=n(8453);const o={sidebar_position:3},r="Architecture",c={},h=[{value:"Components",id:"components",level:2},{value:"Authentication and Authorization",id:"authentication-and-authorization",level:2},{value:"Step-up Authentication",id:"step-up-authentication",level:2}];function l(e){const t={a:"a",admonition:"admonition",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,i.jsx)(t.p,{children:'Our consumer bank scenario is illustrated by a sample application that will require step-up authentication for "high-risk" transactions.\nThis section provides an overview of the components used in this application, and how they interact with one another.'}),"\n",(0,i.jsx)(t.h2,{id:"components",children:"Components"}),"\n",(0,i.jsx)(t.p,{children:"We can distinguish the following six components:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"The Banking client. Strictly speaking, these are two components, as we will be using both a web client and a mobile client. The Web client is implemented using React. The mobile client is a native iOS app."}),"\n",(0,i.jsx)(t.li,{children:"The Banking API. This is a server component hosting a banking API, used by both clients to perform transactions such as money transfers between accounts."}),"\n",(0,i.jsx)(t.li,{children:"The Identity Provider. This is a separate server component that is used in conjunction with both API servers. It is used to host user identities and issue tokens to secure the banking API."}),"\n",(0,i.jsx)(t.li,{children:"The WebAuthn server. This is the same component as used before in the demo application, but configured slightly differently in order to support the use of attestation and multiple assurance levels."}),"\n",(0,i.jsx)(t.li,{children:"The Database server, used as before by the WebAuthn server to store passkey registration and authentication data, as well as used by the banking API server to store bank account information."}),"\n",(0,i.jsx)(t.li,{children:"Lastly, the FIDO Metadata service is used by the WebAuthn server for obtaining attestation data to assess the assurance level of different authenticators. Note that this is a cloud service so we do not need to deploy this service locally."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"These components and their interconnections are illustrated in the following diagram:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Components",src:n(6103).A+"",width:"3086",height:"1154"})}),"\n",(0,i.jsx)(t.p,{children:"In this section we will focus on the first three components as they interact in a specific way to implement our high assurance use case using step-up authentication."}),"\n",(0,i.jsx)(t.p,{children:"Refer to the following diagram:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Architecture",src:n(4596).A+"",width:"2648",height:"1432"})}),"\n",(0,i.jsx)(t.p,{children:"The server components have a different role:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The Bank API is used for client access to a user's bank account"}),"\n",(0,i.jsx)(t.li,{children:"The Bank Authorization Server is used to authenticate users and authorize access to the bank API."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"authentication-and-authorization",children:"Authentication and Authorization"}),"\n",(0,i.jsxs)(t.p,{children:["As with the demo application, an OpenID Connect Provider is used to host user identities.\nIt is used by the web and mobile clients to authenticate users.\nAfter a user successfully authenticates, the clients are issued an ID Token containing information on the user's identity together with details on the authentication event.\nTo learn more about OpenID Connect, see ",(0,i.jsx)(t.a,{href:"https://openid.net/developers/",children:"openid.net/developers"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["After authentication, the clients need to interact with the banking API server to access their account.\nTo authorize the client to access a bank account on behalf of the user, the ",(0,i.jsx)(t.a,{href:"https://oauth.net/2/",children:"OAuth 2.0"})," protocol is used."]}),"\n",(0,i.jsx)(t.p,{children:"OAuth2 works with access tokens to protect APIs.\nWhen a user is authenticated and an ID Token is issued to their client,\nthe client also receives an access token that can be used to access the banking API.\nThe banking API requires this access token whenever a client wants to access a user's bank account.\nThe access token is bound to the user that authorized the issuance of the token, and has a limited validity period.\nThe banking API will validate the access token and only perform actions on the user's account if the token is valid."}),"\n",(0,i.jsx)(t.admonition,{title:"A note on Relying Parties",type:"danger",children:(0,i.jsx)(t.p,{children:"Beware that both the WebAuthn and the OpenID Connect specs use the term Relying Party.\nIn OpenID Connect a Relying Party is the service that outsources user authentication to an Identity Provider (the OpenID Provider).\nIn WebAuthn a Relying Party is the web application that uses WebAuthn to register and authenticate users.\nIn our banking application, we use KeyCloak to authenticate users using passkeys.\nStrictly speaking, the banking application is the OpenID Relying Party, but the OpenID Provider is the WebAuthn Relying Party.\nHere, we will not distinguish the two as the OpenID Provider and Banking application are closely connected ."})}),"\n",(0,i.jsx)(t.p,{children:"This user flow is depicted in the diagram below:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Login Flow",src:n(1659).A+"",width:"2648",height:"1432"})}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"The client application initially does not have an access token, so cannot yet access the Bank API.\nTo obtain a token, the client is first redirected to the bank's OAuth 2.0 Authorization Server (AS) with a request for an access token.\nThe Authorization Server first needs to authenticate the user in order to know which user to issue an access token for.\nIn our case, the Authorization Server is also the OpenID Provider, and the user is authenticated with their passkey."}),"\n",(0,i.jsx)(t.li,{children:"When authentication is successful, an access token is issued for that user and returned to the client."}),"\n",(0,i.jsx)(t.li,{children:"The client now calls the banking API to access the user's account. Along with the API call, the access token is sent to authorize the call."}),"\n",(0,i.jsx)(t.li,{children:"The banking API validates the access token, and if successful, performs the API call and returns any data as a result of the call to the client."}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{title:"OAuth 2.0 flows",type:"info",children:(0,i.jsxs)(t.p,{children:["Note that we slightly simplified the diagram.\nIn reality, obtaining an access token is slightly more complicated.\nThis is because the access token is returned over a so called back-channel, instead of a front-channel (as the diagram suggests using redirects).\nThis is called the ",(0,i.jsx)(t.em,{children:"authorization code"})," flow in OAuth 2.0."]})}),"\n",(0,i.jsx)(t.h2,{id:"step-up-authentication",children:"Step-up Authentication"}),"\n",(0,i.jsx)(t.p,{children:"Now let's have a look at what happens when a user has authenticated with a copyable passkey (which is assigned a low assurance level),\nbut tries to make an API call that requires a high assurance level."}),"\n",(0,i.jsxs)(t.p,{children:["When calling the API, sending along the obtained access token, the API server will validate the access token before performing the API call.\nLet's assume the access token hasn't expired.\nBut because the API call requires high assurance, the API server will inspect some data associated with the access token.\nThis data is called the ",(0,i.jsx)(t.em,{children:"authentication context class reference"}),", or ACR, and its value is set by the entity that authenticated the user,\nindicating how authentication was performed. In our case, it indicates the assurance level of the associated passkey."]}),"\n",(0,i.jsx)(t.p,{children:"Because the user authenticated using low assurance, the API server will deny the API request, and send back an error message indicating the required assurance level.\nThe client will subsequently return to the Authorization Server to obtain a new access token, but this time specifically requesting to authenticate the user on a high assurance level.\nThis means the Authorization Server will now require the user to use a passkey stored on a security key.\nAssuming the user has registered such a passkey, the user authenticates on a high assurance level and a new access token is issued and returned to the client.\nThis time, the access token is marked with an ACR value indicating high assurance, so when the API call is retried, the server will grant access and perform the API call as requested."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Stepup Flow",src:n(6214).A+"",width:"2648",height:"1432"})})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(6540);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);