"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[816],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var r=a.createContext({}),u=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h=function(e){var t=u(e.components);return a.createElement(r.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),c=u(n),p=o,m=c["".concat(r,".").concat(p)]||c[p]||d[p]||i;return n?a.createElement(m,s(s({ref:t},h),{},{components:n})):a.createElement(m,s({ref:t},h))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=p;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l[c]="string"==typeof e?e:o,s[1]=l;for(var u=2;u<i;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},7571:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>h});var a=n(7462),o=(n(7294),n(3905)),i=n(2004);const s={sidebar_position:4},l="Authentication flows",r={unversionedId:"web-client/auth-flow",id:"web-client/auth-flow",title:"Authentication flows",description:"This section will cover the authentication flows for logging in with a passkey.",source:"@site/docs/web-client/auth-flow.mdx",sourceDirName:"web-client",slug:"/web-client/auth-flow",permalink:"/passkey-workshop/docs/web-client/auth-flow",draft:!1,editUrl:"https://github.com/YubicoLabs/passkey-workshop/tree/main/docs/docs/web-client/auth-flow.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Registration flows",permalink:"/passkey-workshop/docs/web-client/reg-flow"},next:{title:"Mobile client",permalink:"/passkey-workshop/docs/category/mobile-client"}},u={},h=[{value:"Flow overview",id:"flow-overview",level:2},{value:"Event handler",id:"event-handler",level:2},{value:"Usernameless discoverable credential flow",id:"usernameless-discoverable-credential-flow",level:2},{value:"Username non-discoverable credential flow",id:"username-non-discoverable-credential-flow",level:2},{value:"Autofill flow",id:"autofill-flow",level:2},{value:"Checking if autofill is available",id:"checking-if-autofill-is-available",level:3},{value:"Handle autofill request",id:"handle-autofill-request",level:3},{value:"Abort controller",id:"abort-controller",level:4},{value:"Combination flow",id:"combination-flow",level:2},{value:"Hybrid flows",id:"hybrid-flows",level:2}],c={toc:h},d="wrapper";function p(e){let{components:t,...s}=e;return(0,o.kt)(d,(0,a.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"authentication-flows"},"Authentication flows"),(0,o.kt)("p",null,"This section will cover the authentication flows for logging in with a passkey."),(0,o.kt)("p",null,"By the end of this section you will understand how to use both of the ",(0,o.kt)("inlineCode",{parentName:"p"},"/assertion/options")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"/assertion/result")," methods (as defined by our ",(0,o.kt)("a",{parentName:"p",href:"/docs/relying-party/api-def"},"API"),") to implement a webpage that allows a user to authenticate with a passkey"),(0,o.kt)("h2",{id:"flow-overview"},"Flow overview"),(0,o.kt)("p",null,"The diagram below demonstrates how the relying party works with the client, and authenticator to authenticate with a passkey. When interacting with the relying party, the client will leverage both of the ",(0,o.kt)("inlineCode",{parentName:"p"},"/assertion")," methods."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Passkey authentication flow",src:n(5699).Z,width:"1095",height:"1334"})),(0,o.kt)("p",null,"The first call (",(0,o.kt)("a",{parentName:"p",href:"http://localhost:8080/swagger-ui/index.html#/v1/serverPublicKeyCredentialCreationOptionsRequest"},(0,o.kt)("inlineCode",{parentName:"a"},"/attestation/options")),") is used to receive an object that includes the options/configurations that should be used when creating a new credential."),(0,o.kt)("p",null,"The second call (",(0,o.kt)("a",{parentName:"p",href:"http://localhost:8080/swagger-ui/index.html#/v1/serverAuthenticatorAttestationResponse"},(0,o.kt)("inlineCode",{parentName:"a"},"/attestation/result")),") is used to send the newly created passkey to be stored in the relying party."),(0,o.kt)("p",null,"As demonstrated in our section on ",(0,o.kt)("a",{parentName:"p",href:"/docs/web-client/user-flows"},"user flows"),", there are multiple flows that can be used for authentication with a passkey. This guide will cover all three methods, and one additional flow that will allow you to combine all three."),(0,o.kt)("h2",{id:"event-handler"},"Event handler"),(0,o.kt)("p",null,"We will start be declaring a method that will be used to handle both of the discoverable and non-discoverable credential flows."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'import PasskeyServices from "../../services/PasskeyServices";\nimport { get } from "@github/webauthn-json";\n\nconst [username, setUsername] = useState("");\n\nconst authenticateUser = async () => {\n  try {\n    /**\n     * Assume the username is a variable that defaults\n     * as empty (""), or can be changed through\n     * an input field by the user\n     */\n    const assertionOptions = await PasskeyServices.getAssertionOptions(\n      username\n    );\n\n    /**\n     * Attempt to get the assertion using the auth\n     * options\n     */\n    const assertionResult = await get(assertionOptions);\n\n    /**\n     * Send the assertion to the RP\n     */\n    const authenticationResult = await PasskeyServices.sendAssertionResult(\n      assertionOptions.requestId,\n      assertionResult\n    );\n\n    /**\n     * Validate that the key was created\n     * Otherwise display a message\n     */\n    if (authenticationResult.status === "ok") {\n      console.info("Authentication successful");\n    } else {\n      throw new Error("Auth failed");\n    }\n  } catch (e) {\n    console.error(e.getMessage());\n  }\n};\n')),(0,o.kt)("h2",{id:"usernameless-discoverable-credential-flow"},"Usernameless discoverable credential flow"),(0,o.kt)("p",null,"This flow will allow a user to authenticate with a passkey, without providing an identifier/username. This flow is commonly referred to as usernameless."),(0,o.kt)("p",null,"The video below will demonstrate this flow."),(0,o.kt)(i.Z,{controls:!0,width:"100%",height:"100%",url:"/passkey-workshop/videos/auth-modal-sec-key.mp4",style:{marginBottom:"2em"},mdxType:"ReactPlayer"}),(0,o.kt)("p",null,"The user interface items for usernameless passkey authentication is fairly simple; it's just a single button!"),(0,o.kt)("p",null,"The user will click this button to begin the authentication ceremony. The button will trigger an 'onClick' event that will handle the authentication ceremony."),(0,o.kt)("p",null,"Because the global username has been set to empty by default, the call to ",(0,o.kt)("inlineCode",{parentName:"p"},"authenticateUser")," will pass an empty ",(0,o.kt)("inlineCode",{parentName:"p"},"userName")," field to the RP, indicating the use of a discoverable credential flow."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'<Button onClick="{authenticateUser}">Add a new passkey</Button>\n')),(0,o.kt)("h2",{id:"username-non-discoverable-credential-flow"},"Username non-discoverable credential flow"),(0,o.kt)("p",null,"We will continue to expand the flow above to account for users with non-discoverable credentials."),(0,o.kt)("p",null,"The video below will demonstrate this flow."),(0,o.kt)(i.Z,{controls:!0,width:"100%",height:"100%",url:"/passkey-workshop/videos/auth-ndc-sec-key.mp4",style:{marginBottom:"2em"},mdxType:"ReactPlayer"}),(0,o.kt)("p",null,"Non-discoverable credentials require the presence of a username as the RP needs to pass assertion options with an ",(0,o.kt)("inlineCode",{parentName:"p"},"allowCredentials")," list, as the authenticator needs to be explicitly told the credentials to utilize to complete this ceremony."),(0,o.kt)("p",null,"We will start by adding an input field for the username, and a handler that will update our global username field."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'const [username, setUsername] = useState("");\n\nconst onUsernameChange = (e) => {\n  setUsername(e.target.value);\n};\n\n<Form>\n  <Form.Group>\n    <Form.Label>Username</Form.Label>\n    <Form.Control value={username} onChange={onUsernameChange} />\n  </Form.Group>\n</Form>;\n\n/**\n * This is the same button created in the previous section\n */\n<Button onClick="{authenticateUser}">Add a new passkey</Button>;\n')),(0,o.kt)("admonition",{title:"Clicking the button when the username field is empty",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The great thing about this implementation is that the button can work for both discoverable and non-discoverable credential flows."),(0,o.kt)("p",{parentName:"admonition"},"If the username field contains input from the user, the button will invoke a non-discoverable credential flow."),(0,o.kt)("p",{parentName:"admonition"},"If the username field is empty, the button will invoke a discoverable credential flow."),(0,o.kt)("p",{parentName:"admonition"},"Our goal is to demonstrate that it's not difficult to make your application usable by ALL types of WebAuthn authenticators.")),(0,o.kt)("admonition",{title:"Passkeys can be used in this flow",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"As mentioned earlier in this guide, passkeys (discoverable credentials) can be utilized from a non-discoverable credential flow."),(0,o.kt)("p",{parentName:"admonition"},"Keep in mind, non-discoverable credentials cannot be used from discoverable credential flows")),(0,o.kt)("h2",{id:"autofill-flow"},"Autofill flow"),(0,o.kt)("p",null,'Autofill introduces a new paradigm into the traditional "modal" flows that we have demonstrated in previous sections. This allows a user to select a passkey from a dropdown list on the username field, similar to what is done currently with passkeys.'),(0,o.kt)("p",null,"The video below will demonstrate this flow."),(0,o.kt)(i.Z,{controls:!0,width:"100%",height:"100%",url:"/passkey-workshop/videos/auth-touchid.mp4",style:{marginBottom:"2em"},mdxType:"ReactPlayer"}),(0,o.kt)("admonition",{title:"This flow also supports passkeys stored on security keys",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The flow we demonstrated above was done using Touch ID on a MacBook. This flow is not only specific for platform authenticators, and can allow for the use of passkeys on security keys (as supported by the platform)")),(0,o.kt)("p",null,"The use of autofill will require a few different mechanisms in the code, as there are some new properties and requirements that are non-standard to the traditional modal flows."),(0,o.kt)("p",null,"We will begin by implementing an autofill method in isolation, then demonstrate how it can be integrated with the previous modal flows shown on this page."),(0,o.kt)("h3",{id:"checking-if-autofill-is-available"},"Checking if autofill is available"),(0,o.kt)("p",null,"In an autofill flow, the first thing that your client should do is check if autofill is available on your platform, more specifically your browser."),(0,o.kt)("p",null,"As autofill for passkeys is a relatively new feature, it may not yet be implemented in your platform of choice."),(0,o.kt)("p",null,"You can use the method below to verify if your browser has autofill. Note the use of the name conditional mediation, which is another term used to describe autofill in a passkey context."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"/**\n * This method call is a promise, be sure to utilize\n * async in Javascript to get the response\n */\nwindow.PublicKeyCredential.isConditionalMediationAvailable();\n")),(0,o.kt)("p",null,"In an ideal world, this method could work across any browser, but as with autofill this method may not be available. We can extend this method call further to check if this method is available, and the result of the method call if it is. We can assume that if this method is not present, then neither is autofill."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const mediationAvailable = async () => {\n  const pubKeyCred = window.PublicKeyCredential;\n  if (\n    typeof pubKeyCred.isConditionalMediationAvailable === "function" &&\n    (await pubKeyCred.isConditionalMediationAvailable())\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n};\n')),(0,o.kt)("h3",{id:"handle-autofill-request"},"Handle autofill request"),(0,o.kt)("p",null,"When using autofill there are properties in the ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," method parameters that deviate from the standard modal experience. We need to:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Invoke the WebAuthn ",(0,o.kt)("inlineCode",{parentName:"li"},"get")," ceremony as soon as the user enters the webpage"),(0,o.kt)("li",{parentName:"ol"},"Append additional information to the object that is passed into the ",(0,o.kt)("inlineCode",{parentName:"li"},"get")," method."),(0,o.kt)("li",{parentName:"ol"},"Create an abort controller object that can terminate the autofill request (more on this below)"),(0,o.kt)("li",{parentName:"ol"},"Add the autofill property to the username input field")),(0,o.kt)("p",null,"The code sample below will demonstrate methods that can be used to handle the autofill request."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'import PasskeyServices from "../../services/PasskeyServices";\nimport { get } from "@github/webauthn-json";\n\nconst [authAbortController, setAuthAbortController] = useState(\n  new AbortController()\n);\n\nconst passkeySignIn = async () => {\n  try {\n    /**\n     * Call to RP to initiate a\n     * discoverable credential flow\n     */\n    const assertionOptions = await PasskeyServices.getAssertionOptions("");\n\n    /**\n     * Ensure that you set\n     * mediation to conditional\n     * signal to your abort controller\n     */\n    const assertionResult = await get({\n      publicKey: assertionOptions.publicKey,\n      mediation: "conditional",\n      signal: authAbortController.signal,\n    });\n\n    /**\n     * Send the assertion to the RP\n     */\n    const authenticationResult = await PasskeyServices.sendAssertionResult(\n      assertionOptions.requestId,\n      assertionResult\n    );\n  } catch (e) {\n    console.error(e);\n\n    /**\n     * If the WebAuthn get ceremony is cancelled\n     * then create a new abort controller\n     */\n    setAuthAbortController(new AbortController());\n  }\n};\n\n/**\n * This method should be called as soon\n * as the user enters the page\n * In React, this will commonly be the\n * useEffect method\n */\nconst onPageLoad = async () => {\n  if (\n    (await mediationAvailable()) &&\n    authAbortController.signal.aborted === false\n  ) {\n    await passkeySignIn(authAbortController);\n  }\n};\n/**\n * Ensure that the input field has the\n * autoComplete property with "username webauth"\n * as the value\n */\n<Form>\n  <Form.Group>\n    <Form.Label>Username</Form.Label>\n    <Form.Control\n      value={username}\n      onChange={onUsernameChange}\n      autoComplete="username webauthn"\n    />\n  </Form.Group>\n</Form>;\n')),(0,o.kt)("h4",{id:"abort-controller"},"Abort controller"),(0,o.kt)("p",null,"Note the use of an abort controller in the method above. The abort controller acts as a mechanism to terminate the active autofill request."),(0,o.kt)("p",null,"This is important as most of the mainstream browsers will only allow one active WebAuthn request at a time. So while autofill is active, your user may be unable to invoke other authentication flows, or registrations of new passkeys"),(0,o.kt)("p",null,"Cancelling the autofill request OR calling the abort controller will terminate the passkeySignIn method."),(0,o.kt)("p",null,"You can reinvoke the passkeySignIn method, just be sure to instantiate a new abort controller, otherwise the ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," method will fail immediately if you attempt to use an abort controller that has been used."),(0,o.kt)("h2",{id:"combination-flow"},"Combination flow"),(0,o.kt)("p",null,"Finally let's put this all together and create a single sign-in webpage that can handle all three of these flows."),(0,o.kt)("p",null,"This will be a combination of the methods listed above with some slight modifications."),(0,o.kt)("p",null,"Below you will find the full implementation of a combination page."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'import PasskeyServices from "../../services/PasskeyServices";\nimport { get } from "@github/webauthn-json";\n\nconst [authAbortController, setAuthAbortController] = useState(\n  new AbortController()\n);\n\nconst authenticateUser = async () => {\n  try {\n    /**\n     * Kill any current autofill request using the\n     * abort controller\n     * This will allow the non-autofill, modal\n     * request in this method to trigger\n     */\n    authAbortController.abort();\n\n    /**\n     * Assume the username is a variable that defaults\n     * as empty (""), or can be changed through\n     * and input field by the user\n     */\n    const assertionOptions = await PasskeyServices.getAssertionOptions(\n      username\n    );\n\n    /**\n     * Attempt to get the assertion using the auth\n     * options\n     */\n    const assertionResult = await get(assertionOptions);\n\n    /**\n     * Send the assertion to the RP\n     */\n    const authenticationResult = await PasskeyServices.sendAssertionResult(\n      assertionOptions.requestId,\n      assertionResult\n    );\n\n    /**\n     * Validate that the key was created\n     * Otherwise display a message\n     */\n    if (authenticationResult.status === "ok") {\n      console.info("Authentication successful");\n    } else {\n      throw new Error("Auth failed");\n    }\n  } catch (e) {\n    console.error(e.getMessage());\n\n    /**\n     * Re-trigger the autofill request method\n     */\n    passkeySignIn();\n  }\n};\n\nconst passkeySignIn = async () => {\n  try {\n    /**\n     * Call to RP to initiate a\n     * discoverable credential flow\n     */\n    const assertionOptions = await PasskeyServices.getAssertionOptions("");\n\n    /**\n     * Ensure that you set\n     * mediation to conditional\n     * signal to your abort controller\n     */\n    const assertionResult = await get({\n      publicKey: assertionOptions.publicKey,\n      mediation: "conditional",\n      signal: authAbortController.signal,\n    });\n\n    /**\n     * Send the assertion to the RP\n     */\n    const authenticationResult = await PasskeyServices.sendAssertionResult(\n      assertionOptions.requestId,\n      assertionResult\n    );\n  } catch (e) {\n    console.error(e);\n\n    /**\n     * If the WebAuthn get ceremony is cancelled\n     * then create a new abort controller\n     */\n    setAuthAbortController(new AbortController());\n  }\n};\n\n/**\n * This method should be called as soon\n * as the user enters the page\n * In React, this will commonly be the\n * useEffect method\n */\nconst onPageLoad = async () => {\n  if (\n    (await mediationAvailable()) &&\n    authAbortController.signal.aborted === false\n  ) {\n    await passkeySignIn(authAbortController);\n  }\n};\n/**\n * Ensure that the input field has the\n * autoComplete property with "username webauth"\n * as the value\n */\n<Form>\n  <Form.Group>\n    <Form.Label>Username</Form.Label>\n    <Form.Control\n      value={username}\n      onChange={onUsernameChange}\n      autoComplete="username webauthn"\n    />\n  </Form.Group>\n</Form>;\n/**\n * This is the same button created in the previous section\n */\n<Button onClick="{authenticateUser}">Add a new passkey</Button>;\n')),(0,o.kt)("h2",{id:"hybrid-flows"},"Hybrid flows"),(0,o.kt)("p",null,"There is not any specific implementation that needs to be done to enable hybrid authentication. The option to leverage hybrid will always be presented to the user in the modal/autofill menus."),(0,o.kt)(i.Z,{controls:!0,width:"100%",height:"100%",url:"/passkey-workshop/videos/hybrid-auth.mp4",style:{marginBottom:"2em"},mdxType:"ReactPlayer"}))}p.isMDXComponent=!0},5699:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/auth-flow-1aca9e2ec4f1a0e76f94b2851166dae8.jpg"}}]);