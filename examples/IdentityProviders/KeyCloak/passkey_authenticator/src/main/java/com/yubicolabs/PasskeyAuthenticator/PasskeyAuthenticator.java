package com.yubicolabs.PasskeyAuthenticator;

import org.keycloak.authentication.AuthenticationFlowContext;
import org.keycloak.authentication.AuthenticationFlowError;
import org.keycloak.authentication.Authenticator;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.RealmModel;
import org.keycloak.models.UserModel;

import com.fasterxml.jackson.databind.ObjectMapper;

import java.net.URI;
import java.net.URLEncoder;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.http.HttpRequest.BodyPublishers;
import java.net.http.HttpResponse.BodyHandlers;
import java.nio.charset.StandardCharsets;

import javax.ws.rs.core.Response;

import org.jboss.logging.Logger;

public class PasskeyAuthenticator implements Authenticator {

  private static final Logger logger = Logger.getLogger(PasskeyAuthenticator.class);

  ObjectMapper mapper = new ObjectMapper();

  @Override
  public void close() {
    /*
     * @TODO - Autogenerated sub, implement later
     */
  }

  @Override
  public void authenticate(AuthenticationFlowContext context) {
    try {
      /*
       * Validate username
       */
      // Get username from the custom form request
      String username = context.getHttpRequest().getDecodedFormParameters().get("username").get(0);

      // Attempt to locate the user in the realm
      UserModel currentUser = context.getSession().users().getUserByUsername(context.getRealm(), username);

      /**
       * Attempt to discern the user from the userhandle provided by the webauthn
       * authentication ceremony
       * The user handle should reference the ID set for the user in keycloak upon
       * registration
       */
      if (currentUser == null) {
        String userHanlde = context.getHttpRequest().getDecodedFormParameters().get("userHandle").get(0);

        // Attempt to locate the user in the realm
        currentUser = context.getSession().users().getUserById(context.getRealm(), userHanlde);
      }

      // User was found
      if (currentUser != null) {
        logger.info("Current user is: " + currentUser.getUsername());

        context.setUser(currentUser);

        /*
         * Format post request to the Passkey Server
         */

        String jsonString = context.getHttpRequest().getDecodedFormParameters().get("assertionResult").get(0);

        /*
         * Send the post request, and read the result
         */
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("http://host.docker.internal:8080/v1/assertion/result"))
            .header("Content-Type", "application/json")
            .header("Accept", "application/json")
            .POST(BodyPublishers.ofString(jsonString))
            .build();

        HttpResponse<String> response = HttpClient.newBuilder().build().send(request, BodyHandlers.ofString());

        AssertionResult result = mapper.readValue(response.body(), AssertionResult.class);

        // Assertion was valid
        if (result.status.equals("ok")) {
          context.success();
        } else if (result.status.equals("error")) { // Assertion was not valid
          throw new Exception("Credentials were invalid. Please try again");
        } else {
          throw new Exception("There was an unexpected message. Please contact support");
        }

      } else { // User not found
        throw new Exception("Credentials were invalid. Please try again");
      }
    } catch (Exception e) {
      logger.info("There was an issue authenticating the user: " + e.getMessage());
      context.failure(AuthenticationFlowError.ACCESS_DENIED,
          Response
              .seeOther(
                  URI.create("http://localhost:3000/sign_in?status=error&error_message="
                      + URLEncoder.encode("There was an issue with your credentials. Please try again",
                          StandardCharsets.UTF_8)))
              .build());
    }

  }

  @Override
  public void action(AuthenticationFlowContext context) {
    logger.info("******* This action method was called");
  }

  @Override
  public boolean requiresUser() {
    return false;
  }

  @Override
  public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {
    return true;
  }

  @Override
  public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {
    /*
     * @TODO - Autogenerated sub, implement later
     */
  }

}
